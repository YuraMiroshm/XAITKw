from typing import Dict, Any, Iterable, Tuple, List

import PIL.Image
import numpy as np

from xaitk_saliency.interfaces.perturb_image import PerturbImage
from xaitk_saliency.utils.masking import generate_block_masks


class SlidingWindowPerturb (PerturbImage):
    """
    Produce image perturbations based on hard, block-y occlusion areas as
    generated by sliding a window of a configured size.

    For multi-channel input, all channels are occluded at the same time or not
    at all.
    For example, if the input image is an RGB image, for regions masked, R, G
    and B channels will be masked at the same time.
    If the image was a 2x2 white image, one mask of just the upper-left pixel
    might be as follows::

        >>> img = (
        ...    [[[255, 255, 255], [255, 255, 255]],
        ...     [[255, 255, 255], [255, 255, 255]]]
        ... )
        >>> img_mask_example = (
        ...     [[[  0,   0,   0], [255, 255, 255]],
        ...      [[255, 255, 255], [255, 255, 255]]]
        ... )

    Due to the geometry of sliding windows, if the stride given does not evenly
    divide the window size along the applicable axis, then the result plane of
    values when summing the generated masks will not be even.

    Relatedly, if the stride is set to be larger than the window size, the
    resulting plane of summed values will also not be even, as there be
    increasingly long valleys of unperturbed space between masked regions.

    :param window_size: The block window size as a tuple with format
        `(height, width)`.
    :param stride: The sliding window striding step as a tuple with format
        `(height_step, width_step)`.
    """

    def __init__(
        self,
        window_size: Tuple[int, int] = (50, 50),
        stride: Tuple[int, int] = (20, 20),
    ):
        self.window_size: Tuple[int, int] = (int(window_size[0]), int(window_size[1]))
        self.stride: Tuple[int, int] = (int(stride[0]), int(stride[1]))

    def perturb(
        self,
        ref_image: PIL.Image.Image
    ) -> Tuple[List[PIL.Image.Image], np.ndarray]:
        ref_mat = np.asarray(ref_image)
        masks = mask_lhs = generate_block_masks(
            self.window_size,
            self.stride,
            ref_image.size[::-1],
        )
        if ref_mat.ndim > 2:
            mask_lhs = masks[..., None]  # add channel axis for multiplication
        masked_images: Iterable[np.ndarray] = (
            (mask_lhs * ref_mat).astype(ref_mat.dtype)
        )
        masked_images_pil = [
            PIL.Image.fromarray(mi, mode=ref_image.mode)
            for mi in masked_images
        ]
        return masked_images_pil, masks

    @classmethod
    def get_default_config(cls) -> Dict[str, Any]:
        # Minor override for to curry tuple defaults into lists, which are the
        # JSON-parsed types. This is to allow successful equality between
        # default, get_config() and JSON-parsed outputs.
        cfg = super().get_default_config()
        cfg['window_size'] = list(cfg['window_size'])
        cfg['stride'] = list(cfg['stride'])
        return cfg

    def get_config(self) -> Dict[str, Any]:
        return {
            "window_size": list(self.window_size),
            "stride": list(self.stride),
        }
