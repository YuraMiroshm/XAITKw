from typing import Any, Dict, Tuple
import numpy as np
from xaitk_saliency.interfaces.perturb_image import PerturbImage
from scipy.ndimage.filters import gaussian_filter


class SlidingRadial (PerturbImage):
    """
    Produce perturbation matrices generated by sliding a circle occlusion area
    with a configured radius over the area of an image. Passing a sigma value
    will apply a Gaussian filter to the mask, blurring it. This results in a
    smooth transition from full occlusion in the center of the radial to no
    occlusion at the edge.

    Due to the geometry of sliding windows, if the stride given does not evenly
    divide the window size along the applicable axis, then the result plane of
    values when summing the generated masks will not be even.

    Related, if the stride is set to be larger than the circle diameter, the
    resulting plane of summed values will also not be even, as there be
    increasingly long valleys of unperturbed space between masked regions.

    :param radius: The radius of the occlusion area.
    :param sigma: The sigma value for the Gaussian filter applied to mask.
    :param stride: The striding step for the center of the radial as a tuple
        with format `(height_step, width_step)`.
    """

    def __init__(
        self,
        radius: int = 50,
        sigma: int = 0,
        stride: Tuple[int, int] = (20, 20),
    ):
        self.radius: int = int(radius)
        self.sigma: int = int(sigma)
        self.stride: Tuple[int, int] = (int(stride[0]), int(stride[1]))

    def perturb(
        self,
        ref_image: np.ndarray
    ) -> np.ndarray:
        stride_h, stride_w = self.stride
        img_h, img_w = ref_image.shape[:2]

        # Center masks in between pixels
        center_xs = np.arange(0.5, img_w, stride_w)
        center_ys = np.arange(0.5, img_h, stride_h)

        num_masks = len(center_xs) * len(center_ys)

        masks = np.ones((num_masks, img_h, img_w))

        center_xs_m = np.tile(center_xs, len(center_ys))
        center_ys_m = np.repeat(center_ys, len(center_xs))

        y, x = np.ogrid[0:img_h, 0:img_w]

        for i, (center_x, center_y) in enumerate(zip(center_xs_m, center_ys_m)):
            mask = np.ones((img_h, img_w))

            circle = (x-center_x)*(x-center_x) + (y-center_y)*(y-center_y) < self.radius*self.radius

            mask[circle] = 0
            mask = gaussian_filter(mask, sigma=self.sigma)
            masks[i] = mask

        return masks

    @classmethod
    def get_default_config(cls) -> Dict[str, Any]:
        # Minor override to curry tuple defaults into lists, which are the
        # JSON-parsed types. This is to allow successful equality between
        # default, get_config() and JSON-parsed outputs.
        cfg = super().get_default_config()
        cfg['stride'] = list(cfg['stride'])
        return cfg

    def get_config(self) -> Dict[str, Any]:
        return {
            "radius": self.radius,
            "sigma": self.sigma,
            "stride": list(self.stride),
        }
